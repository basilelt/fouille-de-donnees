#!/usr/bin/env python3
"""
Generator script that reads all markdown files from the antiseche directory
and generates a viewer.py with all content embedded inside.
"""

import os
from pathlib import Path


def find_md_files(base_dir):
    """Find all .md files recursively in base_dir."""
    md_files = []
    for root, dirs, files in os.walk(base_dir):
        for file in files:
            if file.endswith(".md"):
                full_path = os.path.join(root, file)
                # Get relative path from base_dir
                rel_path = os.path.relpath(full_path, base_dir)
                md_files.append((rel_path, full_path))
    return sorted(md_files)


def read_file_content(filepath):
    """Read file content with UTF-8 encoding."""
    with open(filepath, "r", encoding="utf-8") as f:
        return f.read()


def escape_content(content):
    """Escape content for embedding in Python string."""
    # Escape backslashes first, then quotes
    content = content.replace("\\", "\\\\")
    content = content.replace('"""', '\\"\\"\\"')
    return content


def generate_viewer(md_files, output_path):
    """Generate viewer.py with embedded markdown content."""

    # Build the embedded content dictionary
    content_entries = []
    for rel_path, full_path in md_files:
        content = read_file_content(full_path)
        escaped_content = escape_content(content)
        # Use forward slashes for consistency
        key = rel_path.replace("\\", "/")
        content_entries.append(f'    "{key}": """{escaped_content}"""')

    embedded_dict = "{\n" + ",\n".join(content_entries) + "\n}"

    viewer_code = f'''# Auto-generated viewer.py with embedded markdown content
# Generated by generate_viewer.py

EMBEDDED_CONTENT = {embedded_dict}


def strip_markdown(text):
    """Strip basic markdown syntax from text."""
    import re
    # Remove headers
    text = re.sub(r"^#+\\s*", "", text, flags=re.MULTILINE)
    # Remove links
    text = re.sub(r"\\[([^\\]]+)\\]\\([^\\)]+\\)", r"\\1", text)
    # Remove bold
    text = re.sub(r"\\*\\*([^\\*]+)\\*\\*", r"\\1", text)
    # Remove italic
    text = re.sub(r"\\*([^\\*]+)\\*", r"\\1", text)
    # Remove code blocks
    text = re.sub(r"```[\\s\\S]*?```", "", text)
    # Remove inline code
    text = re.sub(r"`([^`]+)`", r"\\1", text)
    # Remove lists
    text = re.sub(r"^[\\s]*[-\\*\\+]\\s*", "", text, flags=re.MULTILINE)
    return text


def display_text(text, max_lines=20):
    """Display text in chunks for limited screen."""
    lines = text.split("\\n")
    for i in range(0, len(lines), max_lines):
        chunk = "\\n".join(lines[i : i + max_lines])
        print(chunk)
        if i + max_lines < len(lines):
            input("Press Enter to continue...")


def list_courses():
    """List all available courses from embedded content."""
    files = sorted(EMBEDDED_CONTENT.keys())
    return files


def view_courses():
    """View all courses by listing and displaying embedded content."""
    files = list_courses()
    if not files:
        print("No courses found.")
        return
    print("Available courses:")
    for i, file in enumerate(files):
        print(f"{{i+1}}. {{file}}")
    choice = input("Enter number to view (or 'q' to quit): ")
    if choice.lower() == "q":
        return
    try:
        idx = int(choice) - 1
        if 0 <= idx < len(files):
            content = EMBEDDED_CONTENT[files[idx]]
            stripped = strip_markdown(content)
            display_text(stripped)
        else:
            print("Invalid choice.")
    except ValueError:
        print("Invalid input.")


def search_courses(query):
    """Search for query in all embedded content."""
    files = list_courses()
    results = []
    for file in files:
        content = EMBEDDED_CONTENT[file]
        if query.lower() in content.lower():
            results.append(file)
    if not results:
        print("No matches found.")
        return
    print("Matching files:")
    for i, file in enumerate(results):
        print(f"{{i+1}}. {{file}}")
    choice = input("Enter number to view (or 'q' to quit): ")
    if choice.lower() == "q":
        return
    try:
        idx = int(choice) - 1
        if 0 <= idx < len(results):
            content = EMBEDDED_CONTENT[results[idx]]
            stripped = strip_markdown(content)
            display_text(stripped)
        else:
            print("Invalid choice.")
    except ValueError:
        print("Invalid input.")


def bayes_calculator():
    """Interactive Bayes theorem calculator."""
    print("Bayes Calculator")
    try:
        prior = float(input("Enter prior probability P(H): "))
        likelihood = float(input("Enter likelihood P(E|H): "))
        evidence = float(input("Enter evidence P(E): "))
        posterior = (prior * likelihood) / evidence
        print(f"Posterior probability P(H|E): {{posterior}}")
    except ValueError:
        print("Invalid input. Please enter numbers.")


def euclidean_distance_calculator():
    """Interactive Euclidean distance calculator."""
    print("Euclidean Distance Calculator")
    try:
        n = int(input("Enter number of dimensions: "))
        point1 = []
        point2 = []
        for i in range(n):
            p1 = float(input(f"Enter coordinate {{i+1}} for point 1: "))
            p2 = float(input(f"Enter coordinate {{i+1}} for point 2: "))
            point1.append(p1)
            point2.append(p2)
        distance = sum((a - b) ** 2 for a, b in zip(point1, point2)) ** 0.5
        print(f"Euclidean distance: {{distance}}")
    except ValueError:
        print("Invalid input. Please enter numbers.")


def entropy_calculator():
    """Interactive entropy calculator."""
    print("Entropy Calculator")
    try:
        probs = []
        while True:
            prob = input("Enter probability (or 'done'): ")
            if prob.lower() == "done":
                break
            probs.append(float(prob))
        if not probs:
            print("No probabilities entered.")
            return
        import math
        entropy = -sum(p * math.log2(p) for p in probs if p > 0)
        print(f"Entropy: {{entropy}}")
    except ValueError:
        print("Invalid input. Please enter numbers.")


def execute_math():
    """Simple math expression evaluator."""
    print("Math Executor")
    expr = input("Enter math expression: ")
    try:
        result = eval(expr)
        print(f"Result: {{result}}")
    except:
        print("Invalid expression.")


def main():
    """Main menu."""
    while True:
        print("\\nData Mining Course Viewer and Calculator")
        print("1. View Courses")
        print("2. Search Courses")
        print("3. Bayes Calculator")
        print("4. Euclidean Distance Calculator")
        print("5. Entropy Calculator")
        print("6. Execute Math")
        print("7. Quit")
        choice = input("Choose an option: ")
        if choice == "1":
            view_courses()
        elif choice == "2":
            query = input("Enter search query: ")
            search_courses(query)
        elif choice == "3":
            bayes_calculator()
        elif choice == "4":
            euclidean_distance_calculator()
        elif choice == "5":
            entropy_calculator()
        elif choice == "6":
            execute_math()
        elif choice == "7":
            break
        else:
            print("Invalid choice.")


if __name__ == "__main__":
    main()
'''

    with open(output_path, "w", encoding="utf-8") as f:
        f.write(viewer_code)

    print(f"Generated {output_path} with {len(md_files)} embedded markdown files.")


def main():
    # Get the directory where this script is located
    script_dir = Path(__file__).parent.resolve()

    # Find all markdown files
    md_files = find_md_files(script_dir)

    print(f"Found {len(md_files)} markdown files:")
    for rel_path, _ in md_files:
        print(f"  - {rel_path}")

    # Generate the viewer
    output_path = script_dir / "viewer.py"
    generate_viewer(md_files, output_path)


if __name__ == "__main__":
    main()
